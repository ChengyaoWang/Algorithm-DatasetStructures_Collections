# include <queue>
# include <vector>
# include <algorithm>
# include <unordered_map>
# include <unordered_set>
using namespace std;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
       
        int N = graph.size();
        vector<int> group(N);
        for (int i = 0; i < N; ++i) group[i] = i;
        
        auto find = [&](int id) {
            while (group[id] != id) {
                group[id] = group[group[id]];
                id = group[id];
            }
            return id;
        };

        vector<int> clean;
        unordered_set<int> initial_set(initial.begin(), initial.end());
        for (int i = 0; i < N; ++i) {
            if (initial_set.find(i) == initial_set.end()) {
                clean.push_back(i);
            }
        }

        for (int i: clean) {
            for (int j: clean) {
                if (i != j && graph[i][j])
                    group[find(i)] = find(j);
            }
        }

        vector<int> groupSize(N, 0);
        for (auto i: clean) ++groupSize[find(i)];

        vector<unordered_set<int>> initial2clean(N);
        vector<int> clean2initial_cnt(N);

        for (int i: initial) {
            for (int j: clean) {
                if (graph[i][j])
                    initial2clean[i].insert(find(j));
            }
            for (int j: initial2clean[i]) {
                ++clean2initial_cnt[j];
            }
        }
        
        // Count 
        int res = initial[0], maxCnt = 0;
        for (auto i: initial) {            
            int cnt = 0;
            for (auto elem: initial2clean[i]) {
                if (clean2initial_cnt[elem] == 1) {
                    cnt += groupSize[elem];
                }
            }
            
            if (cnt > maxCnt || (cnt >= maxCnt && i < res)) {
                maxCnt = cnt;
                res = i;
            }

        }

        return res;
    }
};